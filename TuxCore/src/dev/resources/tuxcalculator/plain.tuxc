cat '?' = comment
? Make ? a comment character while executing this file, so it can be commented.

? Basic catcodes
cat '.'   = decimal sep
cat ','   = element sep
cat ';'   = group sep
cat 'e'   = exp
cat 'E'   = exp
cat '@'   = reference
cat '('   = open
cat ')'   = close
cat '['   = start list
tok '#['  = start vector
tok '@['  = start match
cat ']'   = end
cat '\\'  = lambda
cat 'λ'   = lambda
cat '→'   = follow
tok '->'  = follow
cat ':'   = guard
cat '`'   = escape
cat '…'   = vararg
tok '...' = vararg
cat '_'   = partial
tok 'ans' = answer

? Calculator properties
set precision = 24
set output = 16

? Eagerly bind all the definitions in this file, so later redefinitions won't break our functions
? Will be set back later
set eager = #t

? booleans and void
let void = #v
let true = #t
let false = #f

cat '⊤' = letter
cat '⊥' = letter
let ⊤ = #t
let ⊥ = #f

? A temporary value to create functions that are defined using def later.
? Useful when using higher order functions.
let temp = #v

? Fundamental constants
let pi = #pi
let π = #pi
let e = #e
let i = #i
let id = \x->x

? Basic functions for complex numbers
def re(x) = #re(x)
def im(x) = #im(x)
def ℜ(x) = #re(x)
def ℑ(x) = #im(x)
def conj(x) = #sub(#re(x),#mul(#i,#im(x)))
def polar(r,a) = #polar(r,a)

? Basic functions for dealing with functions
let temp=\f->(\x->x(x))(\x->f(\y...->x(x)(y...)))
def Y(f)=temp(\s->\a...->f(s,a...))

? Basic functions for dealing with lists
let temp=#sub(0,1)
def has(l,v) = #if(#eq(#idx(l,0,#eq_v),temp),false,true)
def distinct(l) = #fold(l,[],(\n,e->#if(has(n,e),n,[n...,e])))

? Basic functions for dealing with vectors
def vec(l...) = #fill(#len(l),1,\r,c->l(#sub(r,1))) ? Required to construct vectors with argument splatting.

? Signs
cat '+' = sign
cat '-' = sign
cat '~' = sign
cat '¬' = sign
cat '¯' = sign
tok '::' = sign
let temp = @[(a:#isl)->#car(a);(a)->a]
def +(a) = temp(a)
def -(a) = #sub(0,a)
def ¬(a) = #xor(a,true)
let temp = @[(a:#isl)->#filter(a,\elem,idx->#and(#eq(#idx(a,0,#eq_elem),idx),#eq(#idx(a,#add(idx,1),#eq_elem),#sub(0,1))));(a)->#xor(a,true)]
def ~(a) = temp(a)
def ¯(a) = conj(a)
let temp = @[(a:#ism)->':: on a matrix.';(a)->#cdr(a)]
def ::(a) = temp(a)

? Operators
cat '&' = operator
cat '|' = operator
cat '∩' = operator
cat '∪' = operator
cat '⊎' = operator
cat '⊔' = operator
cat '<' = operator
cat '>' = operator
cat '*' = operator
cat '/' = operator
cat '¦' = operator
cat '÷' = operator
cat '%' = operator
cat '^' = operator
cat '∠' = operator
let temp = \a,b->distinct([a...,b...])
def[-900] ∪(a,b) = temp(a,b)
let temp = @[(a:#isl,b:#isl)->temp(a,b);(a,b)->#or(a,b)]
def[-900] |(a,b) = temp(a,b)
def[-900] ⊎(a,b) = [a...,b...]
let temp = \a,b->distinct(#filter([a...,b...],(\e,i->#if(#and(has(a,e),has(b,e)),false,true))))
def[-900] ⊔(a,b) = temp(a,b)
let temp = @[(a:#isl,b:#isl)->temp(a,b);(a,b)->#xor(a,b)]
def[-900] ~(a,b) = temp(a,b)
let temp = \a,b->distinct(#filter(a,(\e,i->has(b,e))))
def[-800] ∩(a,b) = temp(a,b)
let temp = @[(a:#isl,b:#isl)->temp(a,b);(a,b)->#and(a,b)]
def[-800] &(a,b) = temp(a,b)
let temp = \l,sl->#eq(#idx(l,0,\le->#eq(#idx(sl,0,\sle->#eq(le,sle)),-1)),-1)
let temp = @[(a:#isl,b:#isl)->#and(temp(a,b),temp(b,a));(a,b)->#eq(a,b)]
def[-700] <=>(a,b) = temp(a,b)
? Defining the = operator is a bit tricky as it has the assign catcode and thus, if encountered alone marks the start
? of the definition expression. We temporarily change catcodes to circumvent this.
? The same is true for other operators starting with =
tok 'ASSIGN' = assign
cat '=' ASSIGN operator
def[-700] =>(a,b) ASSIGN #or(#xor(a,true),b)
def[-600] =(a,b) ASSIGN #eq(a,b)
cat '=' ASSIGN assign
tok 'ASSIGN' = invalid
def[-600] <>(a,b) = #xor(#eq(a,b),true)
def[-600] <(a,b) = #lt(a,b)
def[-600] <=(a,b) = #or(#eq(a,b),#lt(a,b))
def[-600] >(a,b) = #lt(b,a)
def[-600] >=(a,b) = #or(#eq(b,a),#lt(b,a))
let temp = @[(h,t:#ism)->':: on a matrix.';(h,t)->[h,t...]]
def[-399] ::(h,t) = temp(h,t)
let temp = @[(a:#isl,b:#isl)->[a...,b...];(a,b)->#add(a,b)]
def[-300] +(a,b) = temp(a,b)
let temp = @[(a:#isl,b:#isl)->#filter(a,(\e,i->#eq(#idx(b,0,#eq_e),-1)));(a,b)->#sub(a,b)]
def[-300] -(a,b) = temp(a,b)
let temp = \l,n->#fill(#mul(#len(l),n),\i->l(#mod(i,#len(l))))
let temp = @[(a:#isl,b:#isr)->temp(a,b);(a:#isr,b:#isl)->temp(b,a);(a,b)->#mul(a,b)]
def[-200] *(a,b) = temp(a,b)
let temp = @[(a:#isv,b:#isv):#len(a)=#len(b)->#fold([#zip(a,b,#mul)...],0,#add);(a,b)->'Can only compute scalar product of same sized vectors.']
def[-200] **(a,b) = temp(a,b)
let temp = @[(a:#isl,b):#eq(#len(a),0)->'Reduce on an empty list.';(a:#isl,b)->#fold(#cdr(#rev(a)),#car(#rev(a)),(\h,t->b(t,h)));(a,b)->#div(a,b)]
def[-200] /(a,b) = temp(a,b)
def[-200] ¦(a,b) = #eq(#mod(b,a),0)
def[-200] ÷(a,b) = #div(a,b)
def[-200] %(a,b) = #mod(a,b)
def[-200] %%(a,b) = (a % b + #abs(b)) % b
def[-99] ^(a,b) = #pow(a,b)
def[100] ∠(r,a) = polar(r,a)

? Postfix operators
cat '!' = post
cat '°' = post
def !(x) = #gamma(x+1,0)
let temp = @[(x):#eq(x,-1)->[];(x):#eq(x,0)->[];(x:#isr):#lt(0,x)&#eq(#mod(x,2),0)->#fill(#cl(x/2,0),\n->2*n+2);(x:#isr):x>0->#fill(#cl(x/2,0),\n->2*n+1);(x)->'Can only compute the double factorial for non-negative integers.']
def !!(x) = #fold(temp(x),1,@*)
def °(x) = x * #pi / 180

? Functions
def sort(l) = #sort(l,@<)
def sort(l,f) = #sort(l,f)
let temp = \l,p->#sort(l,(\a,b->p(a)<p(b)))
def arrange(l,p) = temp(l,#memoize(p))
let temp = @[(x):#eq(x,-1)->'element not found in list';(x)->x]
def index(l,v) = temp(#idx(l,0,#eq_v))

def sqrt(x) = x^0.5
def cbrt(x) = x^(1/3)
def root(n,x) = x^(1/n)

let temp = @[(v:#isv)->sqrt(#fold([#map(v,\x->x*x)...],0,#add));(x)->#abs(x)]
def abs(x) = temp(x)
let temp = \x->#eq(#idx([x...],0,\elem->#if(#eq(elem,0),false,true)),-1)
let temp = @[(x:#isl)->'sgn of list';(x):x=0->0;(x:#isv):temp(x)->x;(x:#isr):x>0->1;(x:#isr):x<0->-1;(x)->x/abs(x)]
def sgn(x) = temp(x)
def gcd(a,b) = #gcd(a,b)
def lcm(a,b) = (a*b)/#gcd(a,b)

def round(x,p) = #rd(x,p)
def round(x) = #rd(x,0)
def ceil(x,p) = #cl(x,p)
def ceil(x) = #cl(x,0)
def floor(x,p) = #fl(x,p)
def floor(x) = #fl(x,0)
let temp = @[(x,p):x<0->#cl(x,p);(x,p)->#fl(x,p)]
def trunc(x,p) = temp(re(x),p)+i*temp(im(x),p)
def trunc(x) = temp(re(x),0)+i*temp(im(x),0)
let temp = \a,b->#if(a<b,a,b)
def min() = 'Minimum of empty list'
def min(l...) = l/temp
let temp = \a,b->#if(a>b,a,b)
def max() = 'Maximum of empty list'
def max(l...) = l/temp
def am() = 'Arithmetic mean of empty list'
def am(l...) = #fold(l,0,@+)/#len(l)
def gm() = 'Geometric mean of empty list'
def gm(l...) = #fold(l,1,@*)^(1/#len(l))
def hm() = 'Harmonic mean of empty list'
def hm(l...) = #len(l)/#fold(#map(l,#div_1),0,@+)
def agm() = 'Arithmetic-geometric mean of empty list'
def agm(l...) = #agm(gm(l...),am(l...))
let temp = @[(a):#eq(#len(a),0)->'med of an empty list';(a):#len(a)%2=0->(a(#len(a)/2)+a((#len(a)/2)-1))/2;(a)->a((#len(a)-1)/2)]
def med() = 'Median of empty list'
def med(l...) = temp(#sort(l,@<))

let temp = @[(x,l,u):l>x->l;(x,l,u):u<x->u;(x,l,u)->x]
def clamp(x,l,u) = temp(x,l,u)
def lerp(p,a,b) = a+(p*(b-a))

def take(l,n) = #filter(l,\elem,idx->idx<n)
def drop(l,n) = #filter(l,\elem,idx->idx>=n)
def slice(l,a,b) = #filter(l,\elem,idx->#and(idx>=a,idx<b))
def filter(l,f) = #filter(l,\elem,idx->f(elem))
def fold(l,s,f) = #fold(l,s,f)
def join(l...) = #fold(l,[],\a,b->[a...,b...])
def map(l,f) = #map(l,f)
def flatMap(l,f) = join(map(l,f)...)
def rev(l) = #rev(l)
? Temporary function to convert a matrix into list of all its elements
let tempMatrixElems = @[(x:#isv)->[x...];(x:#ism)->#fill(#wd(x)*#ht(x),\n->x(1+(n%#ht(x)),1+(#fl(n/#ht(x),0))))]
let temp = \l,f->#fold(#map(l,f),true,#and)
let temp = @[(l:#isl,f)->#fold(#map(l,f),true,#and);(l:#ism,f)->#fold(#map(tempMatrixElems(l),f),true,#and);(l,f)->true]
def forall(l,f) = temp(l,f)
let temp = @[(l:#isl,f)->#fold(#map(l,f),false,#or);(l:#ism,f)->#fold(#map(tempMatrixElems(l),f),false,#or);(l,f)->false]
def exists(l,f) = temp(l,f)
rem tempMatrixElems

let temp = @[(a,b):a=b->[a];(a,b):a>b->#rev(#fill(1+a-b,@+_b));(a,b)->#fill(1+b-a,@+_a)]
def range(a,b) = temp(a,b)
def range(n) = range(1,n)

def fill(a,b,f) = #map(range(a,b),f)
def fill(n,f) = #map(range(n),f)

? zip and merge are rather complicated
? merge with two lists is straightforward
? zip with two lists and vararg zip build on this
? vararg merge builds on vararg zip as the #zip special only allows zipping two lists at once.
? Also special attention is needed to make all those functions work well with matrices as well as lists.
let temp=@[(f,l1:#isl,l2:#isl):#eq(#len(l1),#len(l2))->#zip(l1,l2,f);(f,l1:#isl,l2:#isl)->'Merge on different size lists.';(f,l1:#ism,l2:#ism):#and(#eq(#wd(l1),#wd(l2)),#eq(#ht(l1),#ht(l2)))->#zip(l1,l2,f);(f,l1:#ism,l2:#ism)->'Merge on different size matrices.';(f,l1,l2)->'Merge can only operate on lists or matrices.']
def merge(f,l1,l2)=temp(f,l1,l2)
def zip(l1,l2)=merge(\l...->l,l1,l2)
let temp=\ll,l1->merge(\a,b->[a...,b],ll,l1)
let temp=\start,l1,l->#fold([l1,l...],start,temp) ? start parameter is required to either fill in a list or a vector depending on the contents of l.
let temp=@[(l1:#isl,l)->temp([[]]*#len(l1),l1,l);(l1:#ism,l)->temp(#fill(#ht(l1),#wd(l1),\r,c->[]),l1,l);(l1,l)->'Merge can only operate on lists or matrices.']
def zip(l1,l...)=temp(l1,l)
def merge(f,l1,l...)=#map(zip(l1,l...),\elems->f(elems...))

def sum(a,b,f) = #fold(#map(range(a,b),f),0,@+)
def prod(a,b,f) = #fold(#map(range(a,b),f),1,@*)
def count(a,b,f) = #len(#filter(range(a,b),\elem,idx->f(elem)))
def sum(n,f) = sum(1,n,f)
def prod(n,f) = prod(1,n,f)
def count(n,f) = count(1,n,f)

def deg(x) = x * 180 / #pi
def rad(x) = x * #pi / 180

? For non-negative real integers, only take real part.
? Prevents rounding errors on the imaginary parts
let temp = @[(x:#isr):#eq(#fl(x,0),x)->#re(#gamma(x+1,-1)/#e);(x)->#gamma(x+1,-1)/#e]
def sf(x) = temp(x)
def Gamma(x) = #gamma(x,0)
def Gamma(p,x) = #gamma(p,x)
def gamma(p,x) = #gamma(p,0)-#gamma(p,x)
def Beta(a) = 1
def Beta(a,b) = #div(#gamma(a,0)*#gamma(b,0),#gamma(a+b,0))
let temp = \l->#div(#fold(#map(l,\x->#gamma(x,0)),1,@*),#gamma(#fold(l,0,@+),0))
? Define multivariate Beta with one positional argument,
? so it can't be called with 0 arguments.
def Beta(a,l...) = temp([a,l...])
def Γ(x) = #gamma(x,0)
def Γ(p,x) = #gamma(p,x)
def γ(p,x) = #gamma(p,0)-#gamma(p,x)
def H(n) = sum(n,#div_1)

let temp = @[(n,k):n<k->0;(n,k)->(n!)/((k!)*((n-k)!))]
def nCr(n,k) = temp(n,k)
let temp = @[(n,k):n<k->0;(n,k)->(n!)/((n-k)!)]
def nPr(n,k) = temp(n,k)
let temp = #memoize(@[(n):#if(#eq(#fl(n,0),n),n<=0,true)->'fib is only defined for positive integers';(n):n<=2->1;(n)->(#[1,1;1,0]^(n-2)*#[1,1])(1)])
def fib(n) = temp(n)
def ln(x) = #ln(x)
def W(x) = #w(x)
def ld(x) = #ln(x) / #ln(2)
def lg(x) = #ln(x) / #ln(10)
def log(n,x) = #ln(x) / #ln(n)

def li(x) = #li(x)
def Li(x) = #li(x) - #li(2)
def Ei(x) = #li(#e^x)

let temp = @[(n:#isr):n<=1->false;(n):n=2->true;(n:#isr):n=3->true;(n:#isr)->#eq(#idx(#fill(ceil(sqrt(n)),@+_2),0,\d->gcd(n,d)<>1),-1);(n)->false]
def prime(n) = temp(n)
let temp = @[(n:#isr):n<=0->0;(n)->count(n,\d->#eq(gcd(n,d),1))]
def totient(n) = temp(n)

def T(a) = #fill(#wd(a),#ht(a),\r,c->a(c,r))
def IM(n) = #fill(n,n,\r,c->#if(r=c,1,0))
def NM(n,m) = #fill(n,m,\r,c->0)
def NM(n) = #fill(n,n,\r,c->0)
let temp = @[(a:#isv,b:#isv):#len(a)=3&#len(b)=3->#[a(2)*b(3)-a(3)*b(2),a(3)*b(1)-a(1)*b(3),a(1)*b(2)-a(2)*b(1)];(a,b)->'Cross product needs two 3-dimensional vectors.']
def cross(a,b) = temp(a,b)
let temp = @[(a:#ism):#eq(#wd(a),#ht(a))->#fold(#fill(#wd(a),\idx->a(idx+1,idx+1)),0,@+);(a:#ism)->'Trace of non-square matrix.';(a)->'Trace needs a matrix.']
def tr(a) = temp(a)
def adj(a) = #adj(a)
def det(a) = #det(a)

def sin(x) = #sin(x)
let temp = @[(x):#eq(x,0)->1;(x)->#div(#sin(x),x)]
def sinc(x) = temp(x)
def cos(x) = #sin(x+(0.5*#pi))
def tan(x) = sin(x) / cos(x)
def sec(x) = 1 / cos(x)
def csc(x) = 1 / sin(x)
def cot(x) = cos(x) / sin(x)
def asin(x) = #asin(x)
def acos(x) = -#asin(x)+(0.5*#pi)
def atan(y,x) = #atan(y,x)
def atan(x) = #atan(x,1)
def asec(x) = acos(1/x)
def acsc(x) = asin(1/x)
def acot(x) = atan(1/x)
def sinh(x) = #sinh(x)
def cosh(x) = #cosh(x)
def tanh(x) = #sinh(x) / #cosh(x)
def sech(x) = 1 / cosh(x)
def csch(x) = 1 / sinh(x)
def coth(x) = #cosh(x) / #sinh(x)
def asinh(x) = ln(x+sqrt((x^2)+1))
def acosh(x) = ln(x+(sqrt(x-1)*sqrt(x+1)))
def atanh(x) = 0.5*(ln(1+x)-ln(1-x))
def asech(x) = acosh(1/x)
def acsch(x) = asinh(1/x)
def acoth(x) = atanh(1/x)

? More signs or operators that need the functions to be in place
cat '√' = sign
def √(x) = sqrt(x)
def[-99] √(n,x) = root(n,x)

cat '∧' = operator
cat '⊼' = operator
cat '∨' = operator
cat '⊽' = operator
cat '⊻' = operator
cat '⇒' = operator
cat '⇔' = operator
cat '≠' = operator
cat '≤' = operator
cat '≥' = operator
cat '∈' = operator
cat '∉' = operator
cat '·' = operator
cat '×' = operator
cat '∘' = operator
cat '∙' = operator
def[-900] ∨(a,b) = #or(a,b)
def[-900] ⊽(a,b) = #xor(#or(a,b),true)
def[-900] ⊻(a,b) = #xor(a,b)
def[-800] ∧(a,b) = #and(a,b)
def[-800] ⊼(a,b) = #xor(#and(a,b),true)
def[-700] ⇔(a,b) = a <=> b
def[-700] ⇒(a,b) = a => b
def[-600] ≠(a,b) = a <> b
def[-600] ≤(a,b) = a <= b
def[-600] ≥(a,b) = a >= b
def[-500] ∈(e,l) = has(l,e)
def[-500] ∉(e,l) = #if(has(l,e),false,true)
def[-500] ∘(a,b) = \arg...->a(b(arg...))
def[-200] ·(a,b) = a * b
def[-200] ×(a,b) = cross(a,b)
def[-200] ∙(a,b) = a ** b
def[-200] //(a,b) = trunc(#div(a,b))

? More functions that rely on the advanced operators
let temp = @[(f):#eq(#len(f),0)->id;(f)->f/@∘]
def chain(f...) = temp(f)

? Remove our temporary value
rem temp

? Reset modifications made only for this file:
? Remove the special catcode, so there is no access to specials by default
? As a last statement, evaluate void to explicitly set ans back to void.
set eager = #f
cat '?' = invalid
cat '#' = invalid
void

dump 'plain'
